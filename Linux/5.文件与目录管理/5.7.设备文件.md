# 设备文件

此节为理解了 Linux 的一些基本知识后补充的  

Linux 将所有的东西都视为文件，设备也不例外，所有的设备文件存放在 `\dev` 目录下  
因此对设备的操作可以像文件一样进行读写，且 Linux 提供了统一的访问接口，如 read、write、open、close 等  

## 块/字符设备文件
字符型设备文件是一种顺序访问的设备文件，例如串行端口和终端  
块型设备文件也称为随机访问设备，例如硬盘驱动器和USB闪存驱动器  

## 设备号
设备号分为主设备号和次设备号  

主设备号标示某一种类的设备，次设备号用来区分同一类型的设备。（这里没太懂）  

linux操作系统中为设备文件编号分配了32位无符号整数，其中前12位是主设备号，后20位为次设备号  

在通过 `ls -l` 查看设备文件时，会显示主次设备号  

## 创建设备文件
``` Shell
mknod 设备名及路径 b 主设备号 次设备号  # 创建块设备文件
mknod 设备名及路径 c 主设备号 次设备号  # 创建字符设备文件
mknod 设备名及路径 p    # 创建 FIFO 命名管道文件
```

-----------------
## file_operations 结构体
设备文件的实现涉及到三个重要的结构体：`inode`，`file`和`file_operations`  

inode 结构体用来存储设备文件的元数据，如设备号，权限，大小等。  

file 结构体用来存储设备文件的状态信息，如当前位置，打开模式，私有数据等。  

**file_operations 结构体**用来存储设备文件的操作函数，如open，read，write，close等。  

file_operations 结构体的定义在 `<linux/fs.h>` 中，主要内容如下：  
``` C
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	int (*readdir) (struct file *, void *, filldir_t);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **);
};
```

其中最常用到的是 open()、close()、read()、write()  


## 注册字符设备
通常为了使 file_operations 结构体和某个设备文件绑定，我们会在 C 语言中使用 `register_chrdev() 函数`，该函数同样定义在 `<linux/fs.h>` 中  
它的大致作用：向内核注册 cdev 结构体,当在用户空间打开设备文件时内核可以根据设备号快速定位此设备文件的file_operations 结构体,从而调用驱动底层的 open,close,read,write,ioctl 等函数  

该函数的定义如下：**`int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)`**  
返回值为负数时表示注册失败  

**参数意义如下**：  
* **major**: 要使用的主设备号，可以指定为 0，表示由系统动态分配，此时该函数的返回值表示分配到的主设备号，缺点是无法提前根据主设备号创建(mknod)设备文件  
* **name**: 设备的名称，其会出现在 `/proc/devices` 文件中，同时，该文件会记录所有的设备文件及其对应的设备号  
* **fops**: 指向提前定义好的 file_operations 结构体，以进行绑定  


## 注销字符设备
与注册相对地，当不使用设备的时候需要将其注销  
函数定义为: **`static inline void unregister_chrdev(unsigned int major, const char *name)`**  



同理，注册和注销块设备可以用类似的函数：**`register_blkdev`** 和 **`unregister_blkdev`**  