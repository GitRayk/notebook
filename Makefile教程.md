# Makefile 教程
## 基础语法
Makefile 最基础的语法是：  
``` Makefile
# 注释顶格写
规则/目标名: 前置条件
    命令
```
值得注意的是，**命令前是制表符而不是空格，Makefile 是对其敏感的**  

规则名的命名是任意且唯一的（不过可以同一系列命令有多个规则名）  

前置条件可以是其它的规则，也可以是文件  
**如果是文件的话，则指定的文件路径下必须存在该文件**  
**如果是其它的规则，则会先按顺序执行指定的前置规则，然后再执行当前这条规则**  
不过如果前置规则重复出现时，并不会执行两次  
**各条规则之间的定义顺序没有任何限制**  

命令则基本上可以参考 Shell 脚本的编写规则，不过其中一点不同的地方是，**Shell 变量的使用需要使用 `$${}`，即两个 \$ 符号**（为了与 Makefile 本身的变量区分，第一个 \$ 可以理解成转义 ）  

如果命令的行首出现 `@`，表示当前命令不会输出，和 Windows DOS 中的 @ 类似(Makefile 会在执行每一条命令前输出一次当前命令)  

之后可以通过 `make 指定规则` 来运行指定规则中的命令(如果没有指定规则，则默认运行第一条规则的)  

**tips：如果将编译生成的文件作为规则名，则重复执行时会提示该文件已经是最新的了**  

----------------------
## 变量
Makefile 中的变量声明位置也没有任何限制，但是通常会放在所有的规则之前并顶格写  

（如果变量声明放在命令段里，可能是被当作命令而不是变量）  

**Makefile 中可以直接使用一些系统的环境变量以及一些内置变量**  

要使用变量时，可以使用这样 `$()`  

### 简单赋值
定义和简单赋值一个变量使用以下语法：  
``` Makefile
变量名 = 值
```

简单赋值的方式又叫延迟赋值，使用该方法赋值的变量只会在被引用时才计算，简单来说就是会引起递归赋值的情况  

### 递归赋值
一种特殊情况是，如果使用一个变量的值作为另一个变量的一部分，那么在基变量被修改后，派生变量也只由其最终的值确定，详见以下的情况：  
``` Makefile
PARENT_PATH = xxx
DERIVED_PATH = $(PARENT_PATH)/yyy
PARENT_PATH = zzz
```
此时执行 Makefile 文件，DERIVED_PATH 将会是 zzz/yyy 而不是 xxx/yyy  

### 立即赋值
为了解决递归赋值的情况，我们会使用立即赋值：  
``` Makefile
PARENT_PATH = xxx
DERIVED_PATH := $(PARENT_PATH)/yyy
PARENT_PATH = zzz
```
立即赋值即是使用 `:=` 来对变量进行赋值，这样赋值的变量会立即计算出来，不会因为基变量的改变而影响派生变量  

### 条件赋值
条件赋值的意义是当一个变量没有被定义的话，则使用当前条件赋值，否则略过这一条赋值语句：  
``` Makefile
VAR = a
VAR ?= b
```
在上述的例子中，由于 VAR 已经存在并被赋值成 a 了，所以不会再被赋值为 b  

### 追加赋值
追加赋值相当于字符串的连接，会将多个值用空格符分割开：  
``` Makefile
VAR = a
VAR += b
```
在上述的例子中，VAR 会变为 `a b`  

### 自动变量
自动变量是指会根据上下文发生变化的特殊变量，常见的自动变量如下：  
* **`$@`**：代指当前的规则名  
* **`$<`**：规则中第一个依赖文件的名称  
* **`$^`**：规则中所有依赖文件的名称（去重之后）  
* **`$*`**：匹配通配符(\%)的部分，例如规则中的 \%.c匹配了foo.c，则 $* 的值为foo  
* **`$?`**：比目标文件更新的所有依赖文件名称列表，以空格分隔(没懂啥意思)  

**Makefile 中的匹配通配符是 `%`**  

-------------------------
## 条件
条件可以嵌套  
### ifeq 和 ifneq
``` Makefile
ifeq (值1, 值2)
    ...
else
    ...
endif

ifneq (值1, 值2)
    ...
else
    ...
endif
```
其中值可以是`$(变量名)`，也可以是常量值，如果两个值相等/不等，则执行后续命令    

### ifdef 和 ifndef
``` Makefile
ifdef 变量名
    ...
else
    ...
endif

ifndef 变量名
    ...
else
    ...
endif
```
该条件判断变量是否被定义，如果有/无定义，则执行后续命令  

-----------------------
## 函数
### 内置函数
* **`$(subst from,to,text)`**：将 text 中的 from 全部替换成 to 后返回  
* **`$(filter pattern,text)`**：返回 text 中匹配 pattern 中的部分  
* **`$(shell command)`**：执行 shell 命令并返回其输出  
* **`$(strip string)`**：返回 string 去除首位空格后的内容  
* **`$(if condition, then-part, else-part)`**：基于条件的真假来选择执行不同的部分  
等等  

### 自定义函数
自定义函数的定义时需要参照如下语法：  
``` Makefile
define 函数名
    命令
endef
```

其中命令中可以通过 `$(1)` 来获取调用函数时的第一个参数，第二、三个参数以此类推  

要调用函数时，需要使用：  
``` Makefile
$(call 函数名, 参数1, 参数2, ...)
```